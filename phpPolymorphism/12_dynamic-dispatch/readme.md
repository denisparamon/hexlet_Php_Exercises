Эта практика демонстрирует реализацию динамической диспетчеризации без использования классов. Она больше рассчитана на изучение существующего кода, чем на написание нового. Разобравшись в ней, вы поймете что динамическая диспетчеризация может быть реализована практически в любом языке.

Когда речь идет не о полиморфном коде, то абстракции создаются как обычно используя конструкторы и селекторы:

```
<?php

use App\Circle;
use App\Square;

$circle = Circle\make(5);
echo Circle\getRadius($circle); // 5

$square = Square\make(10);
echo Square\getSide($square); // 10
```
Если функция должна быть полиморфной, то она создается через специальный (самописный) механизм. Этот механизм описан в файле src/Dispatcher.php и содержит некоторые запрещенные приемы (использование глобальной переменной), которые необходимы для реализации виртуальной таблицы. Будет здорово если вы разберетесь в устройстве этого кода.

В нашем случае добавляется ровно одна полиморфная функция getArea. Сначала посмотрим как этот код работает:

```
<?php

use App\Figure; // Специальный неймспейс, который содержит полиморфную функцию
use App\Circle;
use App\Square;

// Инициализация полиморфных методов
Circle\init();
Square\init();

$circle = Circle\make(5);
$square = Square\make(5);
// Вызов полиморфной функции. В зависимости от типа она идет либо в Circle либо в Square
Figure\getArea($circle); // ~ 78.5
Figure\getArea($square); // 25
```

Теперь реализация. Первым делом создается специальный неймспейс с полиморфной функцией:

```
``<?php

namespace App\Figure;

use App\Dispatcher;

function getArea($self, ...$args)
{
    return Dispatcher\call($self, __FUNCTION__, $args);
}
```

Он вызывает диспетчер, который, в свою очередь, выполняет поиск нужной реализации функции в виртуальной таблице и вызывает ее. Для работы диспетчера нужно чтобы любая абстракция была создана с помощью ассоциативного массива, в котором под свойством name хранится тип сущности:

```
<?php

// src/Circle.php

function make($radius)
{
    return ['name' => __NAMESPACE__, 'data' => ['radius' => $radius]];
}
```
И последний шаг. Нужно создать реализацию функции именно для нашей текущей абстракции. Она делается в функции init:
```
<?php

function init()
{
    Dispatcher\defmethod(__NAMESPACE__, 'getArea', function ($self) {
        return pi() * $self['data']['radius'] ** 2;
    });
}
```
В этом месте происходит добавление функции конкретной абстракции (Circle) в виртуальную таблицу

## src/Square.php
Реализуйте абстракцию Square опираясь на Circle. Эта абстракция должна содержать следующие функции:

Конструктор, который принимает на вход длину стороны
Селектор getSide, который возвращает сторону
Полиморфную функцию getArea, которая возвращает площадь квадрата
```
<?php

use App\Figure;
use App\Square;

Square\init();

$square = Square\make(2);
Square\getSide($square); // 2
Figure\getArea($square); // 4
```